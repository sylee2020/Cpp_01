>>>16조(이수영,원준서) 4주차(2023-09-25) 정리노트
<1> 수업내용 정리
<2> 수업내용 중 이해 안 가던 부분 질의응답
<3> 짝 프로그래밍 및 진행 도중 막힌 부분


<1> 수업내용 정리

[C++ 객체]
'객체'는 실세계를 모델링한 것으로, 상태(State)와 행동(Behavior)으로 이루어집니다.
이 '상태'와 '행동'은 객체가 '데이터'와 '함수(function)' 즉 '멤버변수'와 '멤버함수'로 구성된다는 것입니다.
그런데 객체는 실세계의 실체의 모든 부분을 모델링하는 것이 아니라, 프로그램의 목적에 맞는 꼭 필요한 것만 선별해서 멤버변수와 멤버함수로 모델링된 것입니다.

[C++ 클래스]
클래스는 말 그대로 '틀'입니다. 그 자체로는 다른 것과 상호작용할 수 없습니다. 반면, 객체는 각기 고유한 특성을 담고 있는 것으로 다른 것과 상호작용할 수 있습니다.
수업 시간에 들은 내용 중에 클래스와 객체를 한 번에 이해할 수 있는 예가 있었는데, 신체구조와 각 개인의 개성적인 모습이었습니다.
인체는 눈 2개, 코 1개, 입 1개, 팔 2개, 다리 2개로 구성되는 것은 인체구조의 기본적인 틀, 즉 클래스에 해당합니다. 그런데 각 개인의 눈/코/입의 모양, 팔/다리의 길이는 각각 다릅니다.
교재에 자주 나오는 붕어빵 틀과 붕어빵들을 통해 이해해본다면, 붕어빵 틀은 변하지 않습니다. 그런데 그 안에 슈크림을 넣으면 슈크림 붕어빵이 되고 팥을 넣으면 팥 붕어빵이 됩니다.
틀은 같았지만 어떤 멤버변수/멤버함수를 사용하는지에 따라 각기 다른 고유한 특성을 가진 객체가 생성되는 것이라는 점을 2주차부터 3주에 걸쳐 다양한 예시를 통해 쉽게 이해할 수 있었습니다.

[C++ 객체 생성방법]
객체의 타입이 클래스 이름이라는 것을 여러 번의 실습을 통해 확실히 체득할 수 있었습니다. 그리고 객체의 특정 값을 설정할 때는 객체 이름.멤버변수를 적을 때 '. 연산자'가 쓰입니다.
예제 실습 초반에는 객체를 생성하고 객체의 멤버변수에 값을 설정하고 객체의 멤버 합수를 호출하는 코드를 작성하는 것이 아직 낯설었지만, 여러 번 반복하는 과정에서 그 원리를 깨달을 수 있었습니다.
그리고 여러 번의 예제 실습 과정에서 느낀 점은 코드를 눈으로 볼 때는 어떤 의미인지 어떤 흐름으로 진행되는지 알 것 같지만, 막상 보지 않고 프로그래밍을 하려니 막히는 과정을 굉장히 많이 겪었습니다.
직접 손으로 반복하는 과정에서 자연스럽게 기능을 구현할 수 있도록 연습하는 과정이 꼭 필요하다는 점을 강의시간동안 깨달을 수 있었습니다.

[생성자]
생성자는 클래스 이름과 동일하며 매개변수가 0개 이상인 멤버 함수입니다.
생성자는 클래스 선언부에 선언되고 클래스 구현부에서 구현되는데, 그동안 생성자를 선언하지 않았지만 에러가 나지 않았던 이유는 생성자 선언을 안 했을 때도 컴파일러가 생성자를 기본적으로 선언해줬기 때문입니다.
이 때 기본적으로 선언되는 생성자는 그 어떠한 액션도 취하지 않고 어떠한 매개변수도 없습니다.
특히 생성자가 선언되는 순간, 그 객체에 해당하는 메모리 공간이 할당된다는 점을 그림을 통해 확인하는 과정들과 그 그림이 기억에 남습니다.
그동안 코드를 작성할 때는 기능 위주로 생각하면서 작성하는데, 이 기능을 구현하려면 어떤 코드를 작성해야할까? 생각하게 됩니다.
그런데 메모리에 얼만큼 할당되는지는 고려하지 못했던 것 같습니다. 3차시 후반부에 배우기도 했지만 함수를 선언하면 재사용성이 높아 편리하지만 그만큼 최적화에도 신경써야 한다는 점이 떠오릅니다.
컴퓨터구조시간에 배웠던 내용을 생각하면서, 어떻게 하면 효율적으로 메모리공간에 데이터를 할당시키면서 최적화할 수 있을지 고민하는 과정이 필요하다는 점을 깨닫는 수업시간이었습니다.
그리고 '위임 생성자' 부분이 가장 오래 기억에 남는 이유는 이 위임 생성자에 관련된 내용을 수업 시간에 논의하고, 그 코드를 교재를 보지 않고 작성하는 과정에서 여러 번 막혔기 때문이었습니다.
위임 생성자와 타겟 생성자를 나누어 작성하는 과정이 익숙하지 않아서 콜론(:)으로 나뉘었던 기억은 있는데 어떤 생성자를 앞에 쓰고 어떤 생성자를 뒤에 써야 하는지 기억이 나지 않았던 것 같습니다.
그래도 여러 번 막히는 과정을 겪은 후에 서로 어떻게 코드를 작성해야 하는지 충분히 고민한 후에 강의교안과 교재를 다시 봤을 때 그 문장이 강렬하게 기억에 남는 것 같습니다.
이런 식으로 여러 시행착오를 겪고 난 후에 코드를 공부하게 되면, 혼자 예습하거나 공부할 때보다 훨씬 더 오래, 강렬하게 기억에 남는다는 점을 배우는 시간이었습니다. 이 부분은 여러 번의 연습과정이 필요한 것 같습니다.

[소멸자]
메모리 공간을 정리하기 위해 개발자가 직접 작성하는 것으로, 자바의 가비지 컬렉션과 유사합니다. 생성자가 클래스 이름과 동일했다면, 소멸자는 클래스 이름 앞에 ~(물결)을 붙여 선언합니다.
그리고 소멸자도 생성자와 같이 개발자가 직접 선언하지 않더라도 컴파일러가 자동으로 선언해주기 때문에 에러가 발생하지 않습니다.
특히 생성자와 소멸자를 공부하는 과정에서 가장 기억에 남는 점은 '스택' 그림이었습니다. 교수님께서 칠판에 스택 모형을 그리고 push, pop 개념과 함께 내용을 말씀해주셔서 소멸자와 생성자의 순서는 오래 기억날 것 같습니다.
특히 전역 객체와 지역 객체를 push, pop과 함께 말씀해주신 부분이 기억에 남습니다. 예제 3-8에서 global이 붙은 전역 객체가 가장 먼저 생성되어 가장 먼저 실행된다는 점이 기억납니다.
전역 객체는 프로그램이 시작될 때 실행되고, 종료될 때 사라지는 반면, 지역 객체는 지역함수가 실행될 때 생성되었다가, 지역함수 실행이 끝나면 그대로 사라진다는 점은 예제 3-8을 통해 배웠기 때문에 오래 기억이 납니다.
어쩌면 이 내용을 그냥 글로만 쭉 봤다면 오랜 시간이 흘러 여러 내용을 배우게 될 때 상대적으로 빨리 잊혀질 수도 있었지만, 예제를 통해 다시 한 번 해당 내용을 확인하는 과정이 있어서 기억이 잘 나는 것 같습니다.

[접근 지정자(private, protected, public]
public과 private을 자주 사용했는데 큰 의미를 두지는 않았지만 데이터들을 전혀 관련없는 외부로부터 보호하기 위해서는 접근 지정자를 신중하게 잘 사용해야 한다는 점을 다시금 생각하게 됐습니다.
public은 다른 클래스나 다른 패키지에서 접근할 수 있게 오픈된 개념인 반면, private은 자기 클래스에서만 접근할 수 있지, 자기 클래스 외에서는 접근할 수 없다는 점에서 public 지정자와 상반됩니다.
그리고 protected는 앞선 public, private에 비해서는 상대적으로 사용할 일이 적어 개념이 흐릿했는데, 이번 강의를 통해 클래스 자신과 '상속받은 자식' 클래스에서만 접근할 수 있다는 점을 다시 배웠습니다.
'상속'의 개념이 있고, '상속받은 자식 클래스'에서만 접근할 수 있다는 점을 잠시 잊고 있었다 보니 다시는 잊으면 안 되겠다는 생각이 들면서 더 집중이 잘 됐던 것 같습니다.

[인라인 함수의 목적]
길지 않고 "짧은" 길이의 함수가 "자주" 호출될 때 발생하는 오버헤드를 줄이기 위해 인라인 함수를 호출하는데, inline 키워드로 선언됩니다.
강의에서 교수님께서 말씀해주신 것처럼 함수는 '재사용성'이 좋다. 그래서 여러 곳에서 호출될 때 필요한 요소를 잘 갖춘 함수를 잘 작성하는 것이 중요하다고 막연하게 생각하고 있었습니다.
그런데 컴퓨터구조에서 함수를 호출하는 과정이 너무 많을 경우 발생하는 오버헤드 과정을 직접 눈으로 보고, 만일 1부터 10,000까지의 수를 일일이 호출하는 작업이 일어날 때의 과정을 떠올린 적은 없었습니다.
그저 사람이 하기 힘든 이 작업을 컴퓨터가 대신 해주고, 그리고 이 과정을 반복문을 통해서 쉽게 구현할 수 있구나!만 생각했던 것 같습니다.
그동안 해온 생각의 틀이 바뀌면서 인라인 함수가 왜 쓰여야 하는지가 더 와닿을 수 있었던 것 같습니다.

[C++ 구조체 사용 방법 및 클래스와의 차이점]
사실 구조체는 클래스와 크게 다르지 않은데, C와 호환되기 위해서 접근 지정자가 public이라는 점이 C++ 클래스의 접근 지정자가 private인 것과 다를 뿐입니다.
이 내용을 알기 전까지 C++ 교재를 구입하고 목차를 쭉 훑어볼 때 느낀 점은 C++에서의 구조체는 어떻게 구현될까 어떤 내용을 새로 배우게 될까하는 막연한 생각이었는데,
강의를 들으면서 C의 코드를 C++에서도 이어쓰기 위해 public을 사용하는구나를 알고 C에서 struct를 쓰던 것과 달리 쓰지 않아도 된다는 점을 알게 돼서 자바의 구조체와 비교하며 강의를 들을 수 있었습니다.

[헤더 파일, cpp 파일 분리]
3차시 후반부 전까지는 선언부와 구현부를 하나의 cpp 파일 안에서 작성했기 때문에 이렇게 계속 작성한다고 생각했습니다.
그런데 선언부는 헤더 파일(.h)로 작성하고, 구현부는 cpp 파일(.cpp)로 작성하고, int main() 부분은 따로 main.cpp로 작성된다는 점을 새롭게 배웠습니다.
'조건 컴파일문'을 사용해서 파일 이름이 중복되는 경우를 방지하는 과정을 거친다면, 헤더 파일과 cpp 파일을 분리해도 컴파일 오류를 방지할 수 있다는 점도 같이 기억에 오래 남습니다.
왜 분리를 하지? 그동안 실습할 때는 하나의 cpp 파일에 작성했는데? 하는 고민의 과정, 그리고 파일을 분리하는 모듈화 과정, 이게 재사용성에 도움이 된다는 설명은 고민의 과정에 대한 해답이 되었습니다.
지난 3-4주동안의 강의를 들으면서 느낀 점은 어떤 개념을 배울 때 생긴 의문점이 있고, 그 궁금한 점을 충분히 고민하거나 서로 논의하는 과정을 거치고, 그 후에 관련 내용을 배울 때 더 오래 기억난다는 점입니다.
실무에 나갔을 때 개인으로 하는 작업보다 협업하고 서로 논의하는 과정을 거치면서 프로젝트를 진행하게 되는데 함께 논의하는 과정에서 혼자 공부할 때보다 더 깊이 배운다는 점을 다시 한 번 더 느낄 수 있었습니다.


<2> 수업내용 중 이해 안 가던 부분 질의응답

[생성자]
Q) 예습할 때, 강의자료에서 이해가 안 되는 점이 한 가지 있었습니다. ppt 20페이지에 있는 "중복된 생성자 중 하나만 실행"이라는 문장이었습니다.
강의 교재를 보기 전에 강의 교안으로 먼저 예습을 하는 과정에서 중요한 부분을 확인한 후에 교재로 예습을 합니다. 그런데 PPT에 있는 간단한 문장 '중복된 생성자 중 하나만 실행'이라는 문구 자체만 보고서는 내용을 이해하기가 어려웠습니다.

A) 나름 생각해보기로는 여러 생성자를 선언하더라도, 호출된 생성자 하나만 실행한다는 의미로 받아들였습니다.
저희가 오늘 실습한 예제 3-3의 경우에 Circle()도 있었고 Circle(int r)도 있었습니다. 이 두 생성자는 중복된 생성자입니다. 매개변수만 다르지 이름이 중복되기 때문입니다.
하지만 Circle pizza(30);은 매개변수가 없는 Circle()이 아니라 Circle(int r) 하나만 실행한다. 이렇게 이해하면 좋을 것 같습니다.

느낀 점) 강의 교안의 문구만 봐서는 그 의미를 정확히 판단하기 어려울 수 있습니다. 교재 또는 수업을 통해 궁금했던 점이 해결된 적이 많았는데 이번에는 조금 어려웠던 것 같습니다.
그래도 이후 예제를 통해 그 의미를 나름대로 떠올려볼 수 있었습니다.


<3> 짝 프로그래밍 및 진행 도중 막힌 부분

[Pair Programming]
>>>1차시
1. Pair Programming 예제 3-2 실습
[첨부파일1] 예제 3-2실습.png
#include <iostream>
using namespace std;

class Rectangle {
public:
	// 선언
	int width;
	int height;
	double getArea();
};

// 구현
double Rectangle::getArea() {
	return width * height;
}


int main() {
	Rectangle rect;
	rect.width = 3;
	rect.height = 5;
	cout << "사각형의 면적은 " << rect.getArea() << endl;
}

느낀 점) 선언부와 구현부로 나누어 작성해야 하고, 선언부에서 생성하기만 한 것이 구현부에서는 실제 리턴값까지 나타나는 과정을 배웠습니다.
그리고 구현부에서 Rectangle::getArea()의 형식으로 작성해야 한다는 점을 새롭게 배웠습니다. 클래스명::구현할 함수의 문법이 바로 나오지 않고 막혔기 땜누에 익숙하게 잘 나올 수 있도록 여러번 반복해야 겠다고 생각했습니다.


2. 예제 3-4 실습(코드 직접 작성해보고 Pair Programming 논의해보기: 예제 3-4는 3-3과 달리, 왜 굳이 위임생성자를 만들었을까? 그냥 생성자와 위임 생성자의 차이는 무엇일까?
[첨부파일2] 예제 3-4실습.png
#include <iostream>
using namespace std;

class Circle {
public:
	int radius;
	Circle();
	Circle(int r);	// 굳이 왜 위임생성자 만들었을까 논의 / 그냥 생성자와 위임생성자했을때
	double getArea();
};

// 3-3과 달리 추가된 부분(13-22행)
Circle::Circle() : Circle(1) { }

Circle::Circle(int r) {
	radius = r;
	cout << "반지름 " << radius << "원 생성" << endl;
}

double Circle::getArea() {
	return 3.14 * radius * radius;
}

int main() {
	Circle donut;
	double area = donut.getArea();
	cout << "donut 면적은 " << area << endl;
	
	Circle pizza(30);
	area = pizza.getArea();
	cout << "pizza 면적은 " << area << endl;
}

논의) 매개변수가 없는 생성자는 반지름을 1이라는 숫자로 특정해주고,
int r을 매개변수로 갖는 생성자는 반지름을 r로 받는다는 것 외에
출력시키는 내용을 담고 있는 코드인 cout << "반지름" << radius << "원 생성" << endl;은 같습니다.
매개변수가 없는 생성자의 반지름(radius)의 값이었던 1을, 매개변수가 없던 생성자 Circle()에서 Circle(1)로 하는 생성자를 선언하고(13행)
15행에는 기존에 int r을 매개변수로 갖는 생성자 Circle(int r)을 Circle 클래스 뒤에 콜론2개로 연결한 것입니다.
그러면 반지름(radius)의 값을 각각 선언하던 것과 출력 cout<< 문을 하나로 줄여 간략하게 표현할 수 있습니다.

>>>2차시
1. Pair Programming 논의(ppt 29p): 컴파일러가 기본 생성자를 생성해준다고 배웠는데 왜 컴파일 오류가 났을까?

논의) 물론 컴파일러가 기본 생성자는 자동으로 생성해주지만, 개발자가 생성자를 하나라도 생성해줬다면, 컴파일러는 자동으로 생성해주지 않기 때문에 개발자가 생성하지 않은 부분에서 컴파일 오류가 발생한다고 생각합니다.

2. Pair Programming 예제 3-6: 실행결과를 보지 보고 main()만 보고 원하는 실행 결과가 나오도록 프로그래밍해보세요
[첨부파일2] 예제 3-6실습.png
#include <iostream>
using namespace std;

class Rectangle {
public:
	int width;
	int height;
	Rectangle();
	Rectangle(int width, int height);
	Rectangle(int n);
	double getArea();

	bool isSquare(int width, int height) {
		if (width == height)
			return true;
		else
			false;
	}

};

int main() {
	Rectangle rect1;
	Rectangle rect2(3, 5);
	Rectangle rect3(3);

	if (rect1.isSquare())
		cout << "rect1은 정사각형이다." << endl;
	if (rect2.isSquare())
		cout << "rect2은 정사각형이다." << endl;
	if (rect3.isSquare())
		cout << "rect3은 정사각형이다." << endl;
}

과정) 선언부에 bool isSquare();를 선언만 해줘도 되는데 아직 선언부와 구현부의 구분을 하는 부분이 익숙해지지 않아서 이 부분 코딩하는 데 막히는 부분이 많았습니다.
위임 생성자와 타겟 생성자 개념을 듣는 것으로는 이해가 되었는데 내용을 보지 않고도 스스로 하나씩 코딩하는 부분이 막히다보니 선언부와 구현부를 분리해서 작성하는 과정이 낯설었습니다.
특히 rect3과 같이 두 변(width, height)이 모두 같을 경우에는, 앞 부분에서 막히다 보니 머리가 새하얘져서 어떤 식으로 문장을 작성해야 하는지 생각이 바로 떠오르지 않았습니다.
width = height = n;으로도 작성할 수 있었고 n보다는 너비(width)와 높이(height)를 모두 아우를 수 있는 length라는 변수도 쓸 수 있다는 점을 새롭게 알게 되었습니다.
여러 예제들 중에서도 이 예제가 가장 기억에 남는데, 수업내용을 배우고 곧바로 교안이나 교재를 보지 않고 코딩을 해야 하는 상황에 맞닥뜨리다보니 당황했던 것 같습니다.
그래서 모든 문장들을 고민하며 작성하다보니 이 문장이 왜 쓰여지는지를 깊이 고민하게 되었고, 그래서 제가 부족한 부분이 위임 생성자와 와 타겟 생성자부분이라는 점을 몸소 깨닫게 되었습니다.
내용을 들을 때는 이해가 되지만 막상 작성하려고 할 때 막막하고 떠오르지 않는 일이 조금 두렵기도 하지만 이 과정을 통해 제가 어떤 점을 모르고 아는지 메타인지에 대해 알게 되었고,
그 부분을 집중적으로 더 훈련해야 할 필요성을 느끼게 돼서 다행이라고 생각했습니다.

3. Pair Programming 예제 3-8: 생성순서, 소멸순서를 한 번 실행결과를 보지 않고 서로 논의해보세요

논의) 생성순서: 프로그램이 시작될 때 '전역'이 먼저 생성된 후에 '지역'이 생성되기 때문에, globalDonut(1000), globalPIzza(2000)이 먼저 생성될 것 같아요.
[[그 후에는 '지역'이 순서대로 생성될 텐데, Circle::Circle(1) 에서 막혔습니다.]]
막힌 부분 해결방법: int main() 함수 맨 마지막 줄에 있는 f(10)을 못 봤습니다. 강조표시가 되어있지 않아서 없다고 생각했습니다.

해결된 이후 논의: radius = 1이 들어가서 1이 생성되고, 그 후에 30이 출력될 것입니다. 순차적으로 그렇게 쭉 실행돼서 f()가 실행되어 void f() 안에 있는 100, 200이 출력됩니다. 이렇게 main()이 끝나면, 이제 객체들이 소멸되기 시작할 것입니다.
소멸순서는 생성순서의 역순이기 때문에, 가장 마지막에 생성됐던 200, 그리고 역순으로 100, 30, 1이 소멸될 것입니다. 그리고 맨 처음 생성됐던 '전역'객체가 가장 마지막으로 소멸되고, 그리고 이 때 스택의 개념처럼 전역객체 2개 중에서도 2번째로 생성됐던 객체가 제일 먼저 pop될 것입니다.
따라서 2000, 1000 순으로 소멸되고 프로그램은 종료될 것입니다.
